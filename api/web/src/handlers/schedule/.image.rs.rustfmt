use aws_sdk_s3::{error::SdkError, operation::put_object::{PutObjectError, PutObjectOutput}, primitives::ByteStream, Client};
use axum::{extract::{Multipart, Path}, response::IntoResponse, Extension};
use aws_sdk_s3::Client as S3Client;
use std::sync::Arc;
use std::env;

use entities::*;
use entities::sea_orm::*;
use crate::handlers::response::Response;


pub async fn upload_object(
    client: &Client,
    bucket_name: &str,
    key: &str,
    body: ByteStream,
) -> Result<PutObjectOutput, SdkError<PutObjectError>> {
    client
        .put_object()
        .bucket(bucket_name)
        .key(key)
        .body(body)
        .send()
        .await
}

async fn create_schedule_image(key: &str, schedule_id: i32, db: &DatabaseConnection) {
    let schedule_image = schedule_images::ActiveModel {
        schedule_item_id: Set(schedule_id),
        url: Set(key.to_string()),
        text: Set("".to_string()),
        ..Default::default()
    };

    match schedule_image.insert(db).await {
        Ok(_) => {
            println!("Successfully created the schedule image");
        }
        Err(e) => {
            println!("Failed to create the schedule image: {}", e);
        }
    }
}

pub async fn create(
    Extension(db): Extension<Arc<DatabaseConnection>>, 
    Extension(aws_s3_client): Extension<Arc<S3Client>>,
    Path(id): Path<i32>,
    mut multipart: Multipart,
) -> impl IntoResponse {
    // Upload the image to the S3 bucket
    let bucket_name = env::var("BUCKET_NAME").expect("BUCKET_NAME must be set");
    let folder_name = env::var("FOLDER_NAME").expect("FOLDER_NAME must be set");
    let client = &*aws_s3_client;

    while let Some(field) = multipart.next_field().await.unwrap() {
        let name = field.name().unwrap().to_string();
        match name.as_str() {
            "file" => {
                let original_filename = field.file_name().unwrap_or("default.png").to_string();
                let file_data = field.bytes().await.unwrap().to_vec();

                if file_data.is_empty() {
                    return Response::error("No file data found").into_response();
                }

                println!("Uploading image: {}", original_filename);
                println!("Uploading for ID: {}", id);

                // Prepare the body for the S3 upload
                let body = ByteStream::from(file_data);

                // Set folder name and create S3 key using the original filename
                let s3_key = format!("{}{}", folder_name, original_filename);

                // Upload the image to the S3 bucket
                match upload_object(client, &bucket_name, &s3_key, body).await {
                    Ok(_) => {
                        println!("Successfully uploaded the image to S3.");
                    }
                    Err(_e) => {
                        return Response::error("Failed to upload the image to S3".into()).into_response();
                    }
                };
            }
            _ => {}
        }
    }
    Response::success("Successfully uploaded the image").into_response()
}
